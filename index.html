<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Fallacy Trainer — Othmane</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- React 18 UMD + Babel for JSX -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-neutral-50">
  <div id="root"></div>

  <script type="text/babel">
    const { useEffect, useMemo, useRef, useState } = React;

    // RNG
    function rng(seed) {
      let t = seed >>> 0;
      return () => {
        t += 0x6D2B79F5;
        let r = Math.imul(t ^ (t >>> 15), 1 | t);
        r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
        return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
      };
    }

    const FALLACIES = [
      "ad hominem","straw man","false dilemma","circular reasoning","slippery slope",
      "hasty generalization","appeal to authority","appeal to emotion","post hoc","correlation/causation",
      "composition/division","no true Scotsman","begging the question","equivocation","gambler’s fallacy",
      "bandwagon","red herring","loaded question","genetic fallacy","tu quoque","Texas sharpshooter",
      "appeal to ignorance","special pleading",
    ];
    const DOMAINS = ["news","science","politics","everyday life","ads","tech","sports","health"];
    const pick = (arr, rnd) => arr[Math.floor(rnd() * arr.length)];
    const capitalize = s => s.charAt(0).toUpperCase() + s.slice(1);

    function pickName(rnd){ return pick(["Rana","Ilyas","Marta","Liang","Noura","Miguel","Avery","Fatima","Owen","Leila"], rnd); }
    function pickThingByDomain(d, rnd){ const m={news:"report", science:"paper", politics:"proposal","everyday life":"advice", ads:"campaign", tech:"benchmark", sports:"strategy", health:"trial"}; return m[d] || "claim"; }
    function pickMinorFlaw(rnd){ return pick(["made a typo in a tweet","missed a deadline once","accepted a small grant","changed jobs frequently","forgot to cite a blog"], rnd); }
    function pickPolicy(d, rnd){ return pick(["the citywide congestion fee","AI auditing standards","a universal transit pass","banning single-use plastics","expanding red-light cameras","remote-first schooling","data localization rules","a sugar-sweetened beverage tax"], rnd); }
    function pickExtremeOpposite(d, rnd){ return pick(["abolish all traffic laws","let companies police themselves","make transit illegal","dump trash in the river","turn the city into a surveillance state","ban education"], rnd); }
    function pickCatastrophe(d, rnd){ return pick(["the economy will crash","crime will skyrocket","our freedoms will vanish","public health will collapse","innovation will die"], rnd); }
    function pickBody(d, rnd){ return pick(["this integrity committee","our onboarding policy","the wellness program","the new evaluation metric"], rnd); }
    function pickSmallStep(d, rnd){ return pick(["1-hour deadline extensions","optional homework","trial periods for scooters","anonymous feedback forms"], rnd); }
    function pickWildOutcome(d, rnd){ return pick(["standards will evaporate","budgets will triple","streets will be lawless","no one will ever work again"], rnd); }
    function pickGroup(d, rnd){ return pick(["app users","cyclists","investors","students","drivers","remote workers","gamers","tourists"], rnd); }
    function pickNegativeOutcome(d, rnd){ return pick(["ignored the instructions","missed a payment","got lost","broke the rules"], rnd); }
    function pickCelebrity(rnd){ return pick(["a billionaire influencer","a retired actor","a viral TikTok doctor","a famous podcaster"], rnd); }
    function pickClaim(d, rnd){ return pick(["coffee cures insomnia","AI will remove all jobs by winter","the tax will raise revenue without costs","running barefoot eliminates injuries"], rnd); }
    function pickSympathyTarget(d, rnd){ return pick(["the children","families living paycheck to paycheck","small shop owners","frontline nurses"], rnd); }
    function pickEvent(d, rnd){ return pick(["the mayor's announcement","last month's heatwave","the app's redesign","a celebrity endorsement"], rnd); }
    function pickOutcome(d, rnd){ return pick(["crime","sales","complaints","downtime","bike accidents"], rnd); }
    function pickStat(rnd){ return pick(["ice cream sales","screen time","bald eagle sightings","podcast downloads"], rnd); }
    function pickOtherStat(rnd){ return pick(["drowning incidents","teen anxiety","stock prices","forest fires"], rnd); }
    function pickPart(d, rnd){ return pick(["component","committee member","ingredient","player"], rnd); }
    function pickTrait(rnd){ return pick(["cheap","healthy","honest","fast"], rnd); }
    function pickWhole(d, rnd){ return pick(["computer","team","meal","league"], rnd); }
    function pickIdentity(d, rnd){ return pick(["patriot","scientist","athlete","environmentalist","entrepreneur"], rnd); }
    function pickAction(d, rnd){ return pick(["pay taxes","miss practice","recycle","take a vacation"], rnd); }
    function pickAmbiguousWord(rnd){ return pick(["theory","free","light","natural"], rnd); }
    function pickMeaningA(rnd){ return pick(["well-supported explanation","zero cost","low in weight","occurring in nature"], rnd); }
    function pickMeaningB(rnd){ return pick(["speculation","without restrictions","illumination","healthy"], rnd); }
    function pickConfusion(rnd){ return pick(["science is just guesses","this plan is literally free forever","the diet guarantees health"], rnd); }
    function pickRandomEvent(rnd){ return pick(["coin toss came up heads","lottery numbers were high","the team lost"], rnd); }
    function pickProblem(d, rnd){ return pick(["the budget overrun","the missed safety inspection","the failed A/B test"], rnd); }
    function pickDistraction(d, rnd){ return pick(["this new branding color","last year's holiday party","a nearby city's mascot"], rnd); }
    function pickAccusation(rnd){ return pick(["massaging performance metrics","hiding conflicts of interest","silencing critics"], rnd); }
    function pickIdea(d, rnd){ return pick(["this investment thesis","the nutrition plan","the hiring rubric","the vaccine schedule"], rnd); }
    function pickSource(rnd){ return pick(["a subreddit","a startup newsletter","a TV talk show","a marketing blog"], rnd); }
    function pickInconsistentAct(d, rnd){ return pick(["took a subsidy","worked remotely","flew business class","skipped the vote"], rnd); }
    function pickRemedy(rnd){ return pick(["a herbal extract","blue light glasses","alkaline water","cold showers"], rnd); }
    function pickSpeculativeClaim(d, rnd){ return pick(["microchips in passports track thoughts","aliens live among us","tax cuts pay for themselves"], rnd); }
    function pickProject(d, rnd){ return pick(["our startup","this pilot program","the national initiative","the elite academy"], rnd); }

    const T = {
      "ad hominem": (d, rnd) => \`Ignore \${pickName(rnd)}'s \${pickThingByDomain(d, rnd)}; they once \${pickMinorFlaw(rnd)}, so their argument is worthless.\`,
      "straw man": (d, rnd) => \`People who question the new \${pickPolicy(d, rnd)} secretly want \${pickExtremeOpposite(d, rnd)}; that's why we must reject them outright.\`,
      "false dilemma": (d, rnd) => \`Either we adopt \${pickPolicy(d, rnd)} immediately or \${pickCatastrophe(d, rnd)}—there's no middle ground.\`,
      "circular reasoning": (d, rnd) => \`\${capitalize(pickBody(d, rnd))} works because it's effective, and it's effective because it works.\`,
      "slippery slope": (d, rnd) => \`If we allow \${pickSmallStep(d, rnd)} today, tomorrow \${pickWildOutcome(d, rnd)}—so we must stop it now.\`,
      "hasty generalization": (d, rnd) => \`I met \${Math.random() < 0.5 ? "one" : "two"} \${pickGroup(d, rnd)} who \${pickNegativeOutcome(d, rnd)}; therefore all \${pickGroup(d, rnd)} are like that.\`,
      "appeal to authority": (d, rnd) => \`\${pickCelebrity(rnd)} said \${pickClaim(d, rnd)}, so it must be true.\`,
      "appeal to emotion": (d, rnd) => \`Think of \${pickSympathyTarget(d, rnd)}! If you cared, you'd support \${pickPolicy(d, rnd)} without asking questions.\`,
      "post hoc": (d, rnd) => \`After \${pickEvent(d, rnd)} happened, \${pickOutcome(d, rnd)} increased; so \${pickEvent(d, rnd)} caused it.\`,
      "correlation/causation": (d, rnd) => \`\${capitalize(pickStat(rnd))} correlates with \${pickOtherStat(rnd)}; therefore \${pickOtherStat(rnd)} causes \${pickStat(rnd)}.\`,
      "composition/division": (d, rnd) => \`Each \${pickPart(d, rnd)} is \${pickTrait(rnd)}, so the whole \${pickWhole(d, rnd)} must be \${pickTrait(rnd)}.\`,
      "no true Scotsman": (d, rnd) => \`No real \${pickIdentity(d, rnd)} would ever \${pickAction(d, rnd)}; anyone who does isn't a true \${pickIdentity(d, rnd)}.\`,
      "begging the question": (d, rnd) => \`\${capitalize(pickPolicy(d, rnd))} is justified because it's the right thing to do.\`,
      "equivocation": (d, rnd) => \`Since "\${pickAmbiguousWord(rnd)}" means \${pickMeaningA(rnd)} and also \${pickMeaningB(rnd)}, we can conclude \${pickConfusion(rnd)}.\`,
      "gambler’s fallacy": (d, rnd) => \`\${capitalize(pickRandomEvent(rnd))} has happened \${3 + Math.floor(Math.random()*3)} times in a row; it's definitely due to flip now.\`,
      "bandwagon": (d, rnd) => \`\${Math.floor(1 + Math.random()*10)} million people already support \${pickPolicy(d, rnd)}—join the winning side.\`,
      "red herring": (d, rnd) => \`Yes, \${pickProblem(d, rnd)} is concerning, but have you seen \${pickDistraction(d, rnd)}? Let's talk about that instead.\`,
      "loaded question": (d, rnd) => \`Have you stopped \${pickAccusation(rnd)} while promoting \${pickPolicy(d, rnd)}?\`,
      "genetic fallacy": (d, rnd) => \`\${capitalize(pickIdea(d, rnd))} originated on \${pickSource(rnd)}, so it's unreliable by default.\`,
      "tu quoque": (d, rnd) => \`You did \${pickInconsistentAct(d, rnd)} last year, so your argument for \${pickPolicy(d, rnd)} is invalid.\`,
      "Texas sharpshooter": (d, rnd) => \`Out of \${50 + Math.floor(Math.random()*50)} cases, \${3 + Math.floor(Math.random()*5)} successes with \${pickRemedy(rnd)} prove it works—ignore the rest.\`,
      "appeal to ignorance": (d, rnd) => \`No one has disproven \${pickSpeculativeClaim(d, rnd)}, therefore it's true.\`,
      "special pleading": (d, rnd) => \`\${capitalize(pickProject(d, rnd))} shouldn't be judged by ordinary evidence—it's a visionary exception.\`,
    };

    function generateClaim({ difficulty, allowCombos, forceFallacies, seed }) {
      const r = rng(seed);
      const domain = pick(DOMAINS, r);
      let targets = forceFallacies && forceFallacies.length ? [...forceFallacies] : [pick(FALLACIES, r)];
      if (allowCombos && difficulty !== "easy" && Math.random() < 0.32 && (!forceFallacies || forceFallacies.length < 2)) {
        let other = pick(FALLACIES.filter(f => f !== targets[0]), r);
        targets.push(other);
      }
      if (forceFallacies && forceFallacies.length === 2) targets = [...forceFallacies];
      const parts = targets.map((f, idx) => T[f](domain, r));
      let claim = parts.join(" " + pick(["Moreover, ","And anyway, ","Besides, "], r));
      if (difficulty === "hard") {
        claim = claim
          .replace(/must|will|therefore|prove/gi, m => ({
            must: "clearly must", will: "will inevitably", therefore: "thus, quite obviously", prove: "conclusively prove"
          })[m.toLowerCase()] || m) + (Math.random() < 0.4 ? " Everyone knows this." : "");
      } else if (difficulty === "medium") {
        claim = claim + (Math.random() < 0.25 ? " It's just common sense." : "");
      }
      const correct = [...new Set(targets)];
      const distractors = FALLACIES.filter(f => !correct.includes(f));
      const shuffled = (arr) => {
        const a = [...arr];
        for (let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; }
        return a;
      };
      const options = shuffled([...correct, ...shuffled(distractors).slice(0, 6 - correct.length)]);
      const correctLetters = options.map((o, i) => ({ o, i })).filter(x => correct.includes(x.o)).map(x => String.fromCharCode(65 + x.i));
      return { claim, options, correct, correctLetters, domain };
    }

    function explain(fallacy) {
      const e = {
        "ad hominem": "Attacks the person instead of the argument.",
        "straw man": "Misrepresents the opponent’s position as an extreme.",
        "false dilemma": "Presents only two options, ignoring alternatives.",
        "circular reasoning": "Conclusion is assumed in the premise.",
        "slippery slope": "Predicts a chain of disasters without causal support.",
        "hasty generalization": "Jumps from a small sample to a general rule.",
        "appeal to authority": "Treats status as decisive evidence.",
        "appeal to emotion": "Substitutes feelings for reasons.",
        "post hoc": "Treats sequence as causation.",
        "correlation/causation": "Confuses association with cause.",
        "composition/division": "Unwarranted transfer of properties between parts/whole.",
        "no true Scotsman": "Redefines a group to dodge counterexamples.",
        "begging the question": "Restates conclusion as a premise.",
        "equivocation": "Shifts meaning of a key term mid-argument.",
        "gambler’s fallacy": "Assumes chance has memory.",
        "bandwagon": "Uses popularity as proof.",
        "red herring": "Diverts to an irrelevant issue.",
        "loaded question": "Smuggles a controversial presupposition.",
        "genetic fallacy": "Judges by origin, not evidence.",
        "tu quoque": "Dismisses argument via speaker’s hypocrisy.",
        "Texas sharpshooter": "Cherry-picks clusters after the fact.",
        "appeal to ignorance": "Treats lack of disproof as proof.",
        "special pleading": "Invents exceptions to avoid evidence.",
      };
      return e[fallacy] || "This statement exemplifies the selected fallacy type.";
    }

    function App(){
      const [difficulty, setDifficulty] = useState("medium");
      const [allowCombos, setAllowCombos] = useState(true);
      const [timerOn, setTimerOn] = useState(false);
      const [seconds, setSeconds] = useState(30);
      const [seed, setSeed] = useState(() => Math.floor(Math.random()*1e9));
      const [qIndex, setQIndex] = useState(0);
      const [question, setQuestion] = useState(null);
      const [chosen, setChosen] = useState([]);
      const [revealed, setRevealed] = useState(false);
      const [score, setScore] = useState(0);
      const [streak, setStreak] = useState(0);
      const [asked, setAsked] = useState(0);
      const [mistakes, setMistakes] = useState({});
      const [history, setHistory] = useState([]);
      const timerRef = useRef(null);

      useEffect(() => {
        const saved = localStorage.getItem("fallacy_trainer_state_v1");
        if (saved) {
          try {
            const s = JSON.parse(saved);
            setDifficulty(s.difficulty || "medium");
            setAllowCombos(!!s.allowCombos);
            setTimerOn(!!s.timerOn);
            setSeconds(s.seconds || 30);
            setSeed(s.seed || Math.floor(Math.random()*1e9));
            setScore(s.score || 0);
            setStreak(s.streak || 0);
            setAsked(s.asked || 0);
            setMistakes(s.mistakes || {});
            setHistory(s.history || []);
          } catch {}
        }
      }, []);

      useEffect(() => {
        const s = { difficulty, allowCombos, timerOn, seconds, seed, score, streak, asked, mistakes, history };
        localStorage.setItem("fallacy_trainer_state_v1", JSON.stringify(s));
      }, [difficulty, allowCombos, timerOn, seconds, seed, score, streak, asked, mistakes, history]);

      useEffect(() => { nextQuestion(); }, []);

      useEffect(() => {
        if (!timerOn || revealed) return;
        timerRef.current && clearInterval(timerRef.current);
        let remaining = seconds;
        timerRef.current = setInterval(() => {
          remaining -= 1;
          setSeconds(s => (s>0? s-1 : 0));
          if (remaining <= 0){
            clearInterval(timerRef.current);
            handleSubmit(true);
          }
        }, 1000);
        return () => clearInterval(timerRef.current);
      }, [qIndex, timerOn, revealed]);

      function hardestTwo(){
        const arr = Object.entries(mistakes).map(([k,v]) => ({k,v})).sort((a,b)=>b.v-a.v);
        return arr.slice(0,2).map(x=>x.k);
      }

      function nextQuestion(forceTargets){
        const seed2 = (seed + qIndex*1013 + (forceTargets?37:0)) >>> 0;
        const forceFallacies = forceTargets && forceTargets.length ? forceTargets : ( (asked>0 && asked % 5 === 0) ? hardestTwo() : [] );
        const q = generateClaim({ difficulty, allowCombos, forceFallacies, seed: seed2 });
        setQuestion(q);
        setChosen([]);
        setRevealed(false);
        setQIndex(i=>i+1);
        setSeconds(30);
      }

      function toggleChoice(letter){
        if (revealed) return;
        setChosen(c => c.includes(letter) ? c.filter(x=>x!==letter) : [...c, letter]);
      }

      function handleSubmit(auto=false){
        if (!question || revealed) return;
        const setEq = (a,b) => a.length===b.length && a.every(x=>b.includes(x));
        const correctLetters = question.correctLetters.slice().sort();
        const chosenLetters = chosen.slice().sort();
        const isCorrect = setEq(chosenLetters, correctLetters);
        const pickedFallacies = chosen.map(l => question.options[l.charCodeAt(0)-65]);

        setRevealed(true);
        setAsked(a=>a+1);
        if (isCorrect){
          setScore(s=>s+1);
          setStreak(t=>t+1);
        } else {
          setStreak(0);
          const missed = question.correct.filter(f => !pickedFallacies.includes(f));
          const wrongs = pickedFallacies.filter(f => !question.correct.includes(f));
          setMistakes(m => {
            const mm = { ...m };
            [...missed, ...wrongs].forEach(f => { mm[f] = (mm[f]||0)+1; });
            return mm;
          });
        }

        setHistory(h => [{
          claim: question.claim, correct: question.correct, picked: pickedFallacies,
          options: question.options, domain: question.domain, won: isCorrect
        }, ...h].slice(0,50));
      }

      function next(){ nextQuestion(); }

      if (!question) return <div className="p-6">Loading…</div>;
      const letters = ["A","B","C","D","E","F"];

      return (
        <div className="min-h-screen bg-neutral-50 text-neutral-900">
          <div className="max-w-4xl mx-auto p-6">
            <header className="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-3 mb-6">
              <h1 className="text-2xl font-bold">Logical Fallacy Trainer</h1>
              <div className="flex flex-wrap gap-2 items-center">
                <select className="border rounded-xl px-3 py-2" value={difficulty} onChange={e=>setDifficulty(e.target.value)}>
                  <option value="easy">Easy</option>
                  <option value="medium">Medium</option>
                  <option value="hard">Hard</option>
                </select>
                <label className="flex items-center gap-2 text-sm border rounded-xl px-3 py-2">
                  <input type="checkbox" checked={allowCombos} onChange={e=>setAllowCombos(e.target.checked)} />
                  Allow combos
                </label>
                <label className="flex items-center gap-2 text-sm border rounded-xl px-3 py-2">
                  <input type="checkbox" checked={timerOn} onChange={e=>setTimerOn(e.target.checked)} />
                  Timer
                </label>
                {timerOn && <div className="text-sm font-mono border rounded-xl px-3 py-2">{seconds}s</div>}
                <button className="text-sm border rounded-xl px-3 py-2" onClick={()=>{ setScore(0); setStreak(0); setAsked(0); setMistakes({}); }}>Reset stats</button>
              </div>
            </header>

            <main className="bg-white rounded-2xl shadow p-6">
              <div className="text-xs uppercase tracking-wide text-neutral-500 mb-2">Domain: {question.domain}</div>
              <p className="text-lg leading-relaxed mb-6 select-text">{question.claim}</p>

              <div className="grid sm:grid-cols-2 gap-3 mb-4">
                {question.options.map((opt, idx) => {
                  const letter = letters[idx];
                  const active = chosen.includes(letter);
                  const isCorrect = question.correctLetters.includes(letter);
                  const state = revealed ? (isCorrect ? "border-green-500 bg-green-50" : (active ? "border-red-400 bg-red-50" : "")) : (active ? "border-blue-500 bg-blue-50" : "");
                  return (
                    <button key={idx} onClick={()=>toggleChoice(letter)} className={"text-left border rounded-xl p-3 transition " + state}>
                      <div className="font-semibold mr-2 inline-block w-6">{letter}.</div>
                      <span>{opt}</span>
                    </button>
                  );
                })}
              </div>

              {!revealed ? (
                <div className="flex gap-3">
                  <button className="px-4 py-2 rounded-xl bg-neutral-900 text-white" onClick={()=>handleSubmit(false)}>Submit</button>
                  <button className="px-4 py-2 rounded-xl border" onClick={()=>nextQuestion()}>Skip</button>
                </div>
              ) : (
                <div className="mt-4">
                  <div className="mb-2 font-semibold">Result</div>
                  <div className="mb-2 text-sm">Correct: {question.correctLetters.join(", ")} — {question.correct.join(" + ")}</div>
                  <ul className="text-sm list-disc pl-5 space-y-1 mb-4">
                    {question.correct.map((f,i)=> (
                      <li key={i}><span className="font-semibold">{f}:</span> {explain(f)}</li>
                    ))}
                  </ul>
                  <div className="flex gap-3">
                    <button className="px-4 py-2 rounded-xl bg-neutral-900 text-white" onClick={next}>Next</button>
                  </div>
                </div>
              )}
            </main>

            <footer className="mt-6 grid sm:grid-cols-3 gap-3">
              <div className="bg-white rounded-2xl shadow p-4">
                <div className="text-sm">Score</div>
                <div className="text-2xl font-bold">{score}</div>
              </div>
              <div className="bg-white rounded-2xl shadow p-4">
                <div className="text-sm">Streak</div>
                <div className="text-2xl font-bold">{streak}</div>
              </div>
              <div className="bg-white rounded-2xl shadow p-4">
                <div className="text-sm">Played</div>
                <div className="text-2xl font-bold">{asked}</div>
              </div>
            </footer>

            <section className="mt-6 bg-white rounded-2xl shadow p-4">
              <div className="flex items-center justify-between mb-2">
                <h2 className="font-semibold">Weak spots</h2>
                <button className="text-sm underline" onClick={()=>{
                  const entries = Object.entries(mistakes).sort((a,b)=>b[1]-a[1]).slice(0,2).map(([k])=>k);
                  if (entries.length) nextQuestion(entries);
                }}>Practice weakest</button>
              </div>
              <ul className="text-sm grid sm:grid-cols-2 gap-x-6">
                {FALLACIES.map(f => (
                  <li key={f} className="flex items-center justify-between border-b py-1">
                    <span>{f}</span>
                    <span className="font-mono">{mistakes[f]||0}</span>
                  </li>
                ))}
              </ul>
            </section>

            <section className="mt-6 text-xs text-neutral-500">
              <p>Tip: every 5 questions, the generator biases toward your top two weak fallacies.</p>
            </section>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(<App />);
  </script>
</body>
</html>
